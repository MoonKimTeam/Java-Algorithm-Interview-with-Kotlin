# 자료형

## 자바는 어떤 자료형을 제공할까

자바의 자료형은 원시 자료형, 원시가 아닌 자료형으로 구분할 수 있다. <br>
원시가 아닌 자료형은 사용자 정의 자료형 또는 데이터가 저장되는 위치를 참조한다고 하여 참조 자료형이라고도 한다.

### 원시 자료형

int, boolean, float 등은 모두 원시형이다. java의 원시형은 아래와 같다.

<img width="645" alt="Image" src="https://github.com/user-attachments/assets/c0e114a9-da2d-4531-80de-ca160c68cfa6" />

원시형은 메모리에 정확하게 type 크기만큼의 공간을 할당하고 그 공간을 오로지 값으로 채워넣는다. <br>
자바에서 정수 원시형은 다음과 같이 선언한다. <br>
`int a = 7;` <br>
이렇게 하면 메모리 특정 영역에 4바이트를 할당하고, 그곳에 7이라는 값을 채워넣게 된다.

### 참조 자료형

참조형은 원시형이 아닌 자료형을 말하며, 원시형과 비교해 다음과 같은 차이점이 있다.

- 원시형은 자바 메모리 모델에서 훨씬 더 빠른 영역에 할당된다. 반면 참조형은 좀 더 느린 영역에 할당된다.
- 원시형은 자료형에 따라 크기가 제각각이며, 자료형 크기만큼의 메모리만 할당된다. 반면 참조형은 일정한 크기의 메모리가 할당된다. 대신 크기가 훨씬 크다.
- 참조형은 메소드 호출을 통해 여러 편리한 작업을 수행할 수 있다.
- 원시형은 항상 값이 존재해야 하며, 널이 될 수 없다. 반면 참조형은 널이 될 수 있다.
- 컬렉션의 엘리먼트는 참조형만 가능하다.
- 원시형을 선언하는 키워드는 소문자로 시작하며, 참조형은 대문자로 시작한다.

<img width="320" alt="Image" src="https://github.com/user-attachments/assets/5a4cfa24-ce41-4721-b7c8-63c93d1e7c0e" />

## 자바 컬렉션 프레임워크의 등장

복수 개의 값을 처리하려면 어떤 자료형을 사용하면 될까 ? <br>
가장 먼저 떠오르는건 배열이다. 배열은 복수 개의 자료를 처리하는데 널리 사용된다. <br>
하지만 정적 배열은 사용에 제약이 따르고, 크기를 마음대로 조절할 수 없다.

자바 1.2 버전에 이르러 드디어 자바 컬렉션 프레임워크가 포함됐다. 주요 이점은 다음과 같다.

1. 일관성 있는 API: 동일한 기능을 하는 자료형은 공통 인터페이스를 제공한다. (List, Set 모두 엘리먼트를 삽입하는 메소드는 add()로 동일하다.)
2. 개발 비용 절약: 필수 데이터 구조와 알고리즘은 미리 구현하여 제공하므로 개발자가 일일이 구현할 필요가 없다.
3. 고성능 구현 제공: 잘 만든 고성능 구현을 제공하므로 개발자가 직접 개발할지라도 이보다 더 잘만들기는 어렵다.
4. 재사용 가능: 공통 표준을 제공하므로 재사용이 가능하다.

<img width="557" alt="Image" src="https://github.com/user-attachments/assets/ef4e5510-739d-4ce7-8aa0-e74b6c519731" />

- List: 순서대로 엘리먼트를 모아두는 모음집이다. 배열을 순서대로 쌓는것과 비슷하다.
- Set: List와 유사하지만 중복을 허용하지 않는다.
- Queue: 큐 자료구조 인터페이스다.
  - Deque: 양쪽에서 삽입과 삭제를 처리할 수 있는, 스택과 큐 특징을 모두 갖고 있는 인터페이스로, Queue를 확장해 정의되어 있다.
- Map: Collection을 확장하지 않고 별도로 구현되어 있다. 키/값을 함께 갖는 자료형이다.

### 가장 자주 쓰게 될 리스트

리스트는 순서대로 엘리먼트를 추출하거나 또는 임의의 위치를 추출할 수도 있으며, 검색도 가능하다. <br>
연산이 효율적으로 동작하는 것은 아니며, 구현에 따라 느리게 동작하기도 한다. 리스트를 구현하는 클래스는 다음과 같다.

- ArrayList: 리스트의 가장 기본이 되는 구현이며 가장 자주 쓰게 된다. 시퀀스 형태의 엘리먼트를 동적 배열로 구현한 자료형이다.
- LinkedList: 리스트를 연결리스트로 구현한 자료형이다. 이중 연결 리스트로 구현되어 있다.
- Vector: 자바 초기에 추가된 자료형으로, 지금은 쓰이지 않는다.

### 가장 유용하게 쓰게 될 맵

맵은 키/값을 갖는 자료형으로, Collection을 상속받지 않기 때문에 인터페이스또한 조금 다르다. <br>
엘리먼트를 추가하는 메소드만 해도 add()가 아니라 put()이 사용된다.

- HashMap: 해시 테이블 구조의 자료형으로, 맵이 필요한 경우 대부분 HashMap 자료형을 사용한다. 입력 순서를 보장하지 않는다는 점에 주의해야 한다.
- LinkedHashMap: LinkedHashMap 자료형을 사용하면 입력 순서가 유지된다.
- TreeMap: 값에 따라 순서를 정렬한다. 내부적으로 자가 균형 이진 탐색 트리인 레드-블랙 트리로 구현되어 있으며, 정렬 순서도 임의로 지정할 수 있다.
- Hashtable: 자바 초기에 추가된 자료형으로, 지금은 쓰이지 않는다.

## 초기 자료형의 성능 문제

자바는 1.0 정식 버전을 출시하던 초기 시절부터 목록형 자료형에 대한 고민이 있었다. <br>
자바 컬렉션 프레임워크가 등장한것은 그로부터 2년이나 더 지난 후였고, 그 전에는 C++의 영향을 받아 벡터 형태의 자료형과 해시 테이블 형태의 자료형을 별도로 제공했다. <br>
이 두 자료형은 컬렉션 프레임워크가 등장하기 전에 사용됐던 레거시 자료형으로, 당시만 해도 공통 인터페이스가 없어 각 컬렉션은 제각각 구현을 했고 서로 관계가 없었다. <br>
인터페이스가 다르기 때문에 각 자료형마다 메소드명이나 생성 방식도 제각각이었다.

가장 큰 문제는 성능이 떨어진다는 점이다. <br>
자바 초기 시절에는 동기화(Syncronized)를 과도하게 적용하곤 했다. 아직 CPU 코어가 1개이던 시절이었고, 특별히 문제될 일은 없었다. <br>
그러나 멀티 코어 시대가 열리면서 더이상 동기화를 디폴트로 둘 수 없었다. 하지만 기존 자료형도 하위호환성을 위해 함부로 수정할 수 없었다. <br>
이에 따라 완전히 새로운 자료형을 디자인하게 됐고, Vector는 List와 그 구현 클래스로, Hashtable은 Map 인터페이스와 그 구현 클래스로 대체됐다. <br>
자료형뿐만 아니라 문자열을 조작하는 클래스도 같은 이유로 대체됐다. StringBuffer는 모든 메서드가 동기화로 동작해. StringBuilder로 대체됐다.

## 무한대 크기의 숫자를 저장할 수 있는 자료형

BigInteger라는 자료형은 아무리 큰 숫자도 저장할 수 있는 독특한 자료형이다. <br>
이를 임의 정밀도 정수형이라고도 하는데, 쉽게 말해 무제한 자릿수를 제공하는 정수형을 말한다. <br>
**이는 정수를 숫자의 배열로 간주해서, 자릿수 단위를 단위로 쪼개어 배열 형태로 표현한다.** <br>

예를 들어 12345678910111213141라는 아주 큰 수를 2진수로 바꾸면 다음과 같다. <br>
1101011000101001110100111111001010111011010000110101111111101010111 <br>
이 2진수를 32비트씩 쪼개어 배열에 넣을 3개의 10진수로 나타내면 다음과 같다.

<img width="553" alt="Image" src="https://github.com/user-attachments/assets/0700d1bd-53ae-4d53-b09b-a1afb29ff256" />














