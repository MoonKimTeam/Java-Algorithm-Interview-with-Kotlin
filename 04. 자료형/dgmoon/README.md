# ch.04 자료형

## 자바는 어떤 자료형을 제공할까

- 원시형 vs. 참조형
    - 원시형은 자바 메모리 모델에서 훨신 더 빠른 영역에 할당됨
    - 참조형은 일정한 크기의 메모리가 할당됨
    - 참조형은 메소드 호출을 통해 여러 편리한 작업 수행 가능
    - 원시형은 항상 값이 존재해야 하며 널이 될 수 없음
    - 컬렉션의 엘리먼트는 참조형만 가능
    - 원시형 선언 키워드는 소문자로 시작, 참조형은 대문자
- 원시형을 쓰면 사용하는 메모리의 영역이 다르고, 필요한 최소한의 공간만 이용하여 매우 빠른 연산 가능
- 원시형은 쓰기에 다소 불편하지만 공간과 속도를 최적화 가능
- 자바엔 원시형에 대응하는 래퍼 클래스 제공
- 객체로 선언하면 기존에 원시형으로 할 수 없었던 여러 가지 작업을 할 수 있게 됨
- 참조형은 클래스 객체이므로 여러 메타 정보와 함께 다야한 메소드 제공 가능
- 참조형은 여러 부가 정보가 추가되므로 메모리 점유가 늘어남
- 무분별하게 참조형을 사용해서는 안 됨
- 불리언 원시형은 단 1비트지만, 참조형인 Boolean은 무려 128비트나 차지
- 참조형는 편리하고 다양한 기능을 제공하기 위해 메모리를 많이 사용하고 실행 속도 면에서도 많은 손해 봄
- 자바 컬렉션 프레임워크의 엘리먼트는 참조형만 가능
- 컬렉션 클래스에는 단순히 값만 저장하는게 아니라 객체를 저장하였고, 이에 따라 equals() 등 객체의 여러 부가 메소드도 함께 활용
- 자료구조, 자료형, 추상 자료형
    - 자료구조: 데이터에 효율적으로 접근하고 조작하기 위한 데이터의 조직, 관리, 저장 구조
    - 자료형: 프로그래머가 데이터를 어떻게 사용하는지를 컴파이일러 또는 인터프리터에게 알려주는 일종의 데이터 속성
        - 자료 구조에 비해 훨씬 더 구체적인 형태
        - 어떤 언어에서 지원하는 원시 자료형
    - 추상 자료형: 자료형에 대한 수학적 모델
        - 해당 요형의 자료에 대한 연산들을 명기
        - 행동을 정의할 뿐 실제 구현 방법을 명시하지 않음

## 자바 컬렉션 프레임워크의 등장

- 복수 개의 값을 처리하기 위한 자료형
- 자바 1.2에서 자바 컬렉션 프레임워크 등장
- 주요 이점
    - 일관성 있는 API
    - 개발 비용 절약
    - 고성능 구현 제공
    - 재사용 가능
- 대표 인터페이스
    - List
    - Set
    - Queue
    - Deque
    - Map
- 가장 자주 쓰게 될 리스트
    - ArrayList
    - LinkedList
- 가장 유용하게 쓰게 될 맵
    - HashMap
    - LinkedHashMap
    - TreeMap
- 즉시 꺼내서 쓸 수 있도록 머릿속에 완전히 외워두고 있어야 함

## 초기 자료형의 성능 문제

- 자바 초기 시절에는 동기화를 과도하게 적용함
    - 파이썬은 지금도 이 같은 특징으로 인해 멀티 스레딩에 어려움을 겪고 있음
- 멀티 코어 시대가 열리면서 더 이상 동기화를 디폴트로 둘 수 없음
- 기존 자료형도 하위 호환성을 위해 함부로 수정할 수 없음
- Vector, Stack, Hashtable, 추가로 문자열을 조작하는 StringBuffer는 더 이상 사용해서는 안 됨

## 무한대 크기의 숫자를 저장할 수 있는 자료형

- BigInteger
    - 임의 정밀도 정수형
    - 무제한 자릿수를 제공하는 정수형
- 아무리 큰 숫자라도 연산 메서드를 이용해 자유롭게 계산할 수 있음
- 물론 모든 숫자를 BigInteger로 계산해선 안 됨
    - 여러 부가 작업이 추가되어 계산 속도가 저하되기 때문

## 코틀린은 어떤 자료형을 제공할까

- 완전한 원시형은 제공 안 함
- 타입 추론 진행하여 어떤 자료형인지 자동 판단
- 자바만큼 빠른 속도 <- 코틀린도 참조형을 제공하지만 실제로는 원시형을 감싼 형태

## 코틀린은 컬렉션 프레임워크를 어떻게 구현했을까

- 자바 컬렉션 프레임워크 사용 이유
    - 호환성 높음
    - 자바와 코틀린 간에 호출이 일어날 때 서로 변환할 필요 없음
- 코틀린 자료형에는 자바가 지원하지 않는 풍부한 기능이 매우 많음
    - 자바는 java.util.Collections에 정의된 max() 메서드 사용
    - 코틀린은 바로 max() 메서드 사용 가능
- 확장 함수
    - 자바클래스를 사용하면서도 코틀린에서 좀더 풍부하게 활용할 수 있는 방법 고민했고, 그 결과물
    - 자바에서 클래스에 메서드를 추가하려면 해당 클래스 내부에서 소스 코드 수정해야 함
    - 그러나, 코틀린은 해당클래스 전혀 건드리지 않고도 밖에서 메서드 추가할 수 있는 기능 제공
- listOf()
    - 값을 할당한 이후에는 추가/삭제 등을 지원하지 않으므로 변경 불가능
    - 코틀린은 자바의 컬렉션 프레임워크를 함께 사용하지만 확장 함수 기능 이용해 다양하게 확장
    - 기본적으로 필요한 함수는 이미 미리 확장 해둠
- 함수형 언어에서는 불변성 매무 중요히 여김
    - 무분별한 상태 변경을 막아 디버깅을 쉽게 하고 가독성을 높인다는 장점
- 맵은 기본적으로 ListHashMap 사용
- linkedMapOf()와 특정 조건에 따라 정렬을 유지하는 sortedMapOf() 있음
- 큰 수는 java.mathBigInteger 그대로 사용

## 자바 컬렉션 프레임워크의 실행 속도

- 매우 오래 걸림
- 자바는 기본적으로 초깃값을 10으로 설정하고 1.5배씩 늘려줌(더블링)
- 미리 큰 크기를 잡아주면 훨씬 빠르게 실행됨