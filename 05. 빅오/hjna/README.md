# 빅오

## 빅오

빅오 표기법은 알고리즘의 시간 복잡도를 표현하는 수학적 표기 방법으로, 입력 크기가 무한대로 향할 때 함수의 상한을 설명하는 점근적 실행 시간을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나다. 점근적 실행 시간이란 입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 함수의 실행 시간 추이를 의미한다.

* O(1) - 상수 시간 복잡도

입력값이 아무리 커도 실행 시간이 일정하다. 다음은 입력값을 받으면 단순히 상수를 리턴하는 함수다. 이 함수는 n의 크기가 얼마든 간에 일정한 상수를 반환하므로 O(1)이다. 그러나 전혀 영향을 받지 않기 때문에 궁극의 알고리즘이라 할 수 있다.

* O(log n) - 로그 시간 복잡도

여기서부터 실행 시간은 입력값에 영향을 받는다. 입력값을 계속해서 반으로 나누는데, 연산 횟수가 log n의 계산 결과와 동일하다. 컴퓨터과학에서는 주로 밑이 2를 생략하여 log n으로 표현한다.

* O(n) - 선형 시간 복잡도

정확히 입력값(n)의 크기만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다. 정확히 n의 크기만큼 연산을 진행한다. 실행 시간이 선형(Linear)으로 증가하기 때문에 O(n) 알고리즘을 선형 시간 알고리즘이라고도 한다.

* O(n log n) - 선형 로그 시간 복잡도

입력값만큼 순회하며 log n의 연산이 함께한다. 입력값 n의 크기만큼 순회하면서, 다시 입력값을 받으면 나누기며 log n의 연산을 진행한다. 병합 정렬(Merge Sort)을 비롯한 효율적인 정렬 알고리즘이 이에 해당한다. 적어도 모든 수에 대해 한 번 이상을 비교해야 하는 비교 기반 정렬 알고리즘은 이보다 좋은 알고리즘도 O(n log n)보다 빠를 수 없다

* O(n^2) - 제곱 시간 복잡도

입력값의 제곱만큼 연산한다. n의 크기만큼 다시 n번 연산을 진행한다. 버블 정렬(Bubble Sort) 같은 비효율적인 정렬 알고리즘이 이에 해당한다. 이제 여기서부터는 신중하게 살펴봐야 하는데 입력값이 클 경우 n^2부터는 타임아웃이 발생하는 경우가 잦기 때문이다.

* O(2^n) - 지수 시간 복잡도

입력값의 크기만큼 2배씩 연산한다. 피보나치 수(Fibonacci 수)를 재귀로 계산하는 알고리즘을 구현할 때 이에 해당한다. 2^n만큼 연산을 진행한다.

* O(n!) - 팩토리얼 시간 복잡도

입력값을 1씩 줄여가며 곱셈 연산을 한다. 입력값의 크기만큼 순회하면서, 다시 입력값을 1씩 줄여가며 재귀 호출한다. 여러 번 재귀 호출을 한다. 실제로는 약 2.7 × n!만큼 호출하는데, 여기서 상수 항을 제외하면 시간 복잡도는 O(n!)이다.

일반적으로 O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!) 순서로 성능이 좋다고 평가된다.

### n²과 2ⁿ의 비교

n²은 제곱 시간 복잡도로 입력값의 제곱만큼 연산하는 반면, 2ⁿ은 지수 시간 복잡도로 입력값의 크기만큼 2배씩 연산한다. 작은 입력값에서는 차이가 크지 않지만, 입력값이 커질수록 2ⁿ이 n²보다 훨씬 빠르게 증가한다.


### 빅오를 계산하는 실용적인 방법

연산 횟수를 직접 헤아리는 방법이 가장 쉬운 방법이며, 코드 내에서 count를 직접 세어보는것이 좋다.

### 상한과 최악

빅오(O)는 상한(Upper Bound)을 의미한다. 이 외에도 하한(Lower Bound)을 나타내는 빅오메가(Ω)와 평균을 의미하는 빅세타(Θ)가 있는데, 학계와 달리 업계에서는 빅세타와 빅오를 하나로 합쳐서 단순화해서 표현하려는 경향이 있다.

주의할 점은 상한을 최악의 경우와 혼동하는 것인데, 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 ‘적당히 정확하게’ 표현하는 방법일 뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이라는 점에 유의해야 한다.

* 최악
최악의 경우는 특정 알고리즘이 가장 많은 연산을 수행해야 하는 입력 상황을 의미한다. 이는 입력 데이터의 배치나 특성에 따라 결정되는 실제적인 시나리오이다. 예를 들어 퀵 정렬에서 입력값이 이미 정렬된 상태로 주어질 때가 최악의 경우에 해당하며, 이때 O(n²)의 연산이 필요하다.

* 상한 
상한은 함수의 성장률이 넘지 않는 점근적 한계를 의미한다. 빅오(O) 표기법으로 표현되며, 실제 연산 횟수가 이 상한값보다 작거나 같다는 것을 보장한다. 상한은 입력 크기 n이 매우 클 때의 점근적 근사에만 집중하며, 작은 n값에서의 세부적인 차이는 무시한다.


### 분할 상환 분석

분할 상환 분석(Amortized Analysis)은 빅오와 함께 함수의 동작을 설명할 때 중요한 방법 중 하나다. 이 분석 방법은 알고리즘의 복잡도를 계산할 때 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 등장하게 됐다.

동적 배열은 엘리먼트를 하나씩 추가하다가 용량이 일정 비율 이상 차면 용량을 확장하고 엘리먼트를 모두 복사하는 더블링(7장 참고) 작업을 진행하게 되는데, 동적 배열에서 이 더블링 작업은 어쩌다 한 번 일어나는 일이지만 이로 인해 ‘동적 배열의 엘리먼트 삽입 시 시간 복잡도는 O(n)이다’라고 얘기하는 것은 지나치게 비관적이고 정확하지도 않다이 경우 최악의 경우인 O(n)을 여러 번에 걸쳐 골고루 나누어주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있으며, 이를 우리말로는 ‘분할 상환’ 또는 ‘상각법’이라고 표현한다.

### 복잡도의 특징

알고리즘은 시간과 공간이 트레이드오프 된다고 하는데, 실행시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행시간이 느리다는 이야기가 있다.

